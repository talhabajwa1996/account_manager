// import 'package:account_manager/business_logic/models/ledgermaster.models.dart';

// abstract class AccountManagerApi {
//   Future<List<LedgerMaster>> fetchLedgerMasters();
// }

// class FakeAccountManager implements AccountManagerApi {
//   @override
//   Future<List<LedgerMaster>> fetchLedgerMaster();
// }

// // class FakeAccountManager implements AccountManagerApi {
// //   @override
// //   Future<List<LedgerMaster>> fetchLedgerMasters() {
// //     List<LedgerMaster> list = [];

// //     return list;
// //   }
// // }

// // // This is the contract that all WebApi services must follow. Using an abstract
// // // class like this allows you to swap concrete implementations. This is useful
// // // for separating architectural layers. It also makes testing and development
// // // easier because you can provide a mock implementation or fake data.
// // abstract class WebApi {
// //   Future<List<int>> fetchExchangeRates();
// // }

// // class FakeWebApi implements WebApi {
// //   @override
// //   Future<List<int>> fetchExchangeRates() async {
// //     List<int> list = [];

// //     return list;
// //   }
// // }

// // class FakeDataApi implements WebApi {
// //   @override
// //   Future<List<int>> fetchExchangeRates() async {}
// // }

// // class DataImplementation implements WebApi {
// //   @override
// //   Future<List<int>> fetchExchangeRates() async {}
// // }

// // class FakeDataApi11 implements WebApi {
// //   @override
// //   Future<List<int>> fetchExchangeRates() async {}
// // }
